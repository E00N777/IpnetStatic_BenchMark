// cpp_leak_3.cpp
// 场景：连续使用 new，导致前一次的地址丢失
int main() {
    // 1. 第一次分配堆内存
    int* ptr = new int(10);

    // 2. 再次对同一个指针赋值
    // 这一步是关键：指针 ptr 现在指向了新的地址 (20)。
    // 上一步分配的 (10) 的地址已经彻底丢失，没有任何变量持有它。
    // CSA 会立刻报告：覆盖指针导致内存泄漏。
    ptr = new int(20);

    // 3. 释放
    // 这里只释放了第二个对象 (20)
    delete ptr;

    return 0;
}